One of the most surprising things about programmers is how little thinking most of them actually do. It’s not that they’re incapable of it. They *can* think. They just don’t want to. And the more time I spend around engineers, the more obvious this becomes.

If you want to understand software, you have to understand this phenomenon first.

People assume programming is intellectual work, and therefore programmers are intellectual workers. But most software isn’t produced by thought. It’s produced by habit. By cults. By years of doing the same thing and calling it “experience.”

There’s a strange paradox here: software keeps changing. New tools appear, new technologies rise, new ways of seeing the world emerge. But the people creating software rarely change the way they think. As they gain “experience,” they think less. They simply build thicker walls around their assumptions.

This is the root of most bad engineering.

If you want to see how the average engineer behaves, show them something better than what they currently use—something simpler, cleaner, something that removes an entire category of accidental complexity. Then watch what happens.

They don’t ask whether it’s better.
They ask whether it fits into the little box they already know.

We love our familiar problems more than unfamiliar solutions.

One of the biggest misconceptions about thinking is the belief that it happens automatically. It doesn’t. Thinking is a choice, and it’s a costly one. Real thinking forces you to confront uncertainty. You must rebuild mental models instead of reusing old ones. You must admit you don’t know. You must let go of the identity you built around the old way.

Most programmers don’t want that.
So they pretend that what they already know is “the right way.”

This is why OOP survives.
It lets you feel smart without understanding anything.

Thinking is expensive.
Pretending to think is cheap.

Over time you start to notice there are only two kinds of programmers. The ones who build and the ones who consume.

Builders see new ideas and immediately wonder how they work. They experiment. They prototype. They throw away the old to understand the new. They chase curiosity.

Consumers cling to what they already know. They want recipes. They follow dogmas. They become experts in their own limitations.

If you give builders something unfamiliar, they get excited.
If you give consumers something unfamiliar, they get scared.

The hard part in learning anything truly new isn’t the new idea.
It’s clearing out the old mental furniture blocking your mind.

Unlearning is painful because it feels like losing part of yourself. But it’s also the only path to becoming great.

Meanwhile, the world moves faster than our mental habits. AI automates everything. Tools abstract more and more. Mental walls grow thicker. Default decisions become rigid.

If you refuse to think, you won’t be replaced by AI.
You’ll be replaced by someone who simply understands things better.

The advantage isn’t in knowing more.
It’s in being willing to think deeper.

If you want to escape the comfort trap, you don’t need to study anything exotic. You just have to notice when your mind resists something. That resistance is the signal. It’s pointing exactly where you need to go.

Try the thing that feels annoying.
Question the thing you’ve always done.
Break one assumption per week.
Write small experiments instead of arguments.
Read other people’s ideas.
Be willing to look stupid.

That last one is the hardest.
It’s also the requirement for becoming great.

Almost all progress in programming comes from people who were willing to think while everyone else wasn’t.

The real gap in software isn’t between languages, domains, or stacks.
It’s between those who think and those who don’t.

Everything else flows from that single difference.

If you train yourself to think — really think — you’re already ahead of most engineers. Not because you were born smarter, but because you were willing to be uncomfortable.

**The cost of thinking is discomfort.
That’s why so few people do it.
And that’s why it works.**

